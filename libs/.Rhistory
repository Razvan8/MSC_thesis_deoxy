y_pred<-kappa1(X%*%array(res_lasso$BETA, dim=c(length(res_lasso$BETA),1) )[-1,] )+ res_lasso$BETA[1]*0
y_pred<-kappa1(X%*%array(res_lasso$BETA, dim=c(length(res_lasso$BETA),1) ) )+ res_lasso$BETA[1]*0
print(r2(y,y_pred))
res_lasso<-irlasso.cb(X=X, Y=y, lambda=0.0001, w.lambda=NULL, beta0=NULL,
centering=FALSE, scaling=FALSE, intercept=T,
maxit=10, tol=0.0545, sd.tol=1e-6,
verbose=TRUE)
y_pred<-kappa1(X%*%array(res_lasso$BETA, dim=c(length(res_lasso$BETA),1) )  + res_lasso$BETA[1] )
y_pred<-kappa1(X%*%array(res_lasso$BETA, dim=c(length(res_lasso$BETA),1) )[-1]  + res_lasso$BETA[1] )
print(r2(y,y_pred))
y_pred<-kappa1(X%*%array(res_lasso$BETA, dim=c(length(res_lasso$BETA),1) )[-1]  + res_lasso$BETA[1]*0 )
dim(res_lasso$BETA)
print(r2(y,y_pred))
# Kappa functions
kappa0 <- function(x) {
k0 <- rep(0,length(x))
tt <- which((x<=700)&(x!=0))
k0[tt] <- log((exp(x[tt])-1)/x[tt])
tt <- which(x>700)
k0[tt] <- x[tt] - log(x[tt])
return(k0)
}
kappa1 <- function(x) {
k1 <- rep(1/2,length(x))
tt <- which(abs(x)<=0.0001)
k1[tt] <- 1/2 + x[tt]/12 - x[tt]^3/720 + x[tt]^5/30240
tt <- which(abs(x)>0.0001)
k1[tt] <- 1 - 1/(x[tt]) - 1/(1-exp(x[tt]))
return(k1)
}
kappa2 <- function(x) {
k2 <- rep(1/12,length(x))
tt <- which(abs(x)<=0.015)
k2[tt] <- 1/12 - x[tt]^2/240 + x[tt]^4/6048
tt <- which(abs(x)>0.015)
k2[tt] <- 1/(x[tt])^2 + 1/(2-2*cosh(x[tt]))
return(k2)
}
View(kappa1)
# The next function implements IRLASSO with Continuous Bernoulli response
# The parameter beta0 is the initialization, choosing NULL initializes at zero
# The function allows for centering/scaling (TRUE by default)
# The function allows for intercept (TRUE by default)
irlasso.cb <- function(X, Y, lambda, w.lambda=NULL, beta0=NULL,
centering=TRUE, scaling=TRUE, intercept=TRUE,
maxit=10, tol=0.0545, sd.tol=1e-6,
verbose=FALSE){
if (verbose) print("Performing IRLASSO-NEW")
# CB Likelihood
kappa0 <- function(x) {
k0 <- rep(0,length(x))
tt <- which((x<=700)&(x!=0))
k0[tt] <- log((exp(x[tt])-1)/x[tt])
tt <- which(x>700)
k0[tt] <- x[tt] - log(x[tt])
return(k0)
}
kappa1 <- function(x) {
k1 <- rep(1/2,length(x))
tt <- which(abs(x)<=0.0001)
k1[tt] <- 1/2 + x[tt]/12 - x[tt]^3/720 + x[tt]^5/30240
tt <- which(abs(x)>0.0001)
k1[tt] <- 1 - 1/(x[tt]) - 1/(1-exp(x[tt]))
return(k1)
}
kappa2 <- function(x) {
k2 <- rep(1/12,length(x))
tt <- which(abs(x)<=0.015)
k2[tt] <- 1/12 - x[tt]^2/240 + x[tt]^4/6048
tt <- which(abs(x)>0.015)
k2[tt] <- 1/(x[tt])^2 + 1/(2-2*cosh(x[tt]))
return(k2)
}
# Get variables
X <- as.matrix(X)
Y <- as.matrix(Y)
# Center variables (column-wise)
mu.X <- rep(0, ncol(X))
mu.Y <- rep(0, ncol(Y))
if (centering) {
mu.X <- apply(X, 2, mean)
#mu.Y <- apply(Y, 2, mean)
X <- apply(X, 2, function(v){v-mean(v)})
#Y <- apply(Y, 2, function(v){v-mean(v)})
}
# Scale variables (column-wise)
sd.X <- rep(1, ncol(X))
sd.Y <- rep(1, ncol(Y))
if (scaling) {
sd.X <- apply(X, 2, function(v){max(sd(v), sd.tol)})
#sd.Y <- apply(Y, 2, function(v){max(sd(v), sd.tol)})
X <- apply(X, 2, function(v){v/max(sd(v), sd.tol)})
#Y <- apply(Y, 2, function(v){v/max(sd(v), sd.tol)})
}
# Intercept
if (intercept) {
X <- cbind(1, X)
}
# Get parameters
n <- dim(X)[1]
p <- dim(X)[2]
# Initialization
if (is.null(beta0)){ beta0 <- rep(0, p) }
beta.old <- array(beta0, dim=c(p, 1, length(lambda)))
Z.old <- array(0, dim=c(n, 1, length(lambda)))
W.old <- array(0, dim=c(n, n, length(lambda)))
beta <- array(beta0, dim=c(p, 1, length(lambda)))
Z <- array(0, dim=c(n, 1, length(lambda)))
W <- array(0, dim=c(n, n, length(lambda)))
R <- list()
nc <- 1:length(lambda)
it.stop <- rep(0, length(lambda))
print("here1")
# Run until convergence or stop
counter <- 0
repeat{
if (verbose) print(paste("Performing IRLASSO iter", counter, sep=" "))
# Keep old variables
beta.old <- beta
Z.old <- Z
W.old <- W
# Compute W and Z
eta <- array(0, dim=c(n, 1, length(lambda)))
k.p <- array(0, dim=c(n, 1, length(lambda)))
k.pp <- array(0, dim=c(n, 1, length(lambda)))
if (length(nc)==0) {
if (verbose) print("No lambda left...")
break
}
if (verbose) print(paste("Lambda left", paste(nc, collapse=" ")))
for (m in nc) {
eta[,,m] <- X%*%beta[,,m]
k.p[,,m] <- kappa1(eta[,,m])
k.pp[,,m] <- kappa2(eta[,,m])
k.pp[,,m][which(k.pp[,,m]<0.005)] <- 0.005
W[,,m] <- diag(as.vector(k.pp[,,m]))
Z[,,m] <- eta[,,m] + diag(1/as.vector(k.pp[,,m]))%*%(Y-as.vector(k.p[,,m]))
# Weighted X.W and Z.W on largest component
X.W <- as.matrix(sqrt(W[,,m])%*%X)
Z.W <- as.matrix(sqrt(W[,,m])%*%Z[,,m])
# Compute coefficients for Z.W ~ X.W
# No center/scale X.W, Z.W
# No intercept
if (is.null(w.lambda)) w.lambda <- rep(1,ncol(X.W))
fit.lasso <- glmnet(x=X.W, y=Z.W, family="gaussian", alpha=1, lambda=lambda[m],
standardize=FALSE, intercept=FALSE, penalty.factor=w.lambda)
beta[,,m] <- as.numeric(fit.lasso$beta)
# Compute model selection matrix
if (intercept) {
s.lasso <- which(as.numeric(fit.lasso$beta)[-1]!=0) # not the intercept, at most 0 <= s.lasso <= p-1
R[[m]] <- matrix(0, nrow=p, ncol=length(s.lasso))
R[[m]][1,1] <- 1                                    # always take intercept
if (length(s.lasso)>0) {
for (s in 1:length(s.lasso)) {
i.lasso <- 1 + s.lasso[s]
R[[m]][i.lasso,s] <- 1
}
}
} else {
s.lasso <- which(as.numeric(fit.lasso$beta)!=0)     # no intercept, at most 0 <= s.lasso <= p
R[[m]] <- matrix(0, nrow=p, ncol=length(s.lasso))
if (length(s.lasso)>0) {
for (s in 1:length(s.lasso)) {
i.lasso <- s.lasso[s]
R[[m]][i.lasso,s] <- 1
}
}
}
}
epsilon <- sqrt(apply((beta-beta.old)^2, 3, sum)/apply((beta.old)^2, 3, sum) )
print(paste("Min Divergence", min(epsilon[nc]), sep=" "))
log.like <- apply(beta, 3, function(v) sum((X%*%v)*Y-kappa0(X%*%v)))
log.like.ratio <- log.like - apply(beta.old, 3, function(v) sum((X%*%v)*Y-kappa0(X%*%v)))
print(paste("Min Loglike ratio", min(log.like.ratio[nc]), sep=" "))
if (sum(is.nan(epsilon[nc]))>0) {
nan.stop <- which(is.nan(epsilon))
if (verbose) print(paste("Divergence NaN comps", paste(nan.stop, collapse=" ")))
for (m in nc) {
beta[,,m] <- beta.old[,,m]
Z[,,m] <- Z.old[,,m]
W[,,m] <- W.old[,,m]
}
nc <- setdiff(nc, nan.stop)
}
if ((min(epsilon[nc])<tol)|(min(log.like.ratio[nc])<tol)) {
nc.stop <- which((epsilon<tol)|(log.like.ratio<tol))
it.stop[nc.stop] <- counter
if (verbose) print(paste("Divergence/Loglike stop comps", paste(nc.stop, collapse=" ")))
nc <- setdiff(nc, nc.stop)
}
if (counter==maxit) {
if (verbose) print("Maximum iterarion, no convergence...")
it.stop[which(it.stop==0)] <- counter
break
}
else {
counter <- counter+1
}
}
# Compute coeffs for original variables
beta.tilde <- beta*0
for (m in 1:length(lambda)) {
if (intercept) {
beta.tilde[,,m][1] <- sd.Y[1]*beta[,,m][1] + mu.Y[1] - sd.Y[1]*(mu.X/sd.X)%*%beta[,,m][2:p] # intercept
beta.tilde[,,m][2:p] <- sd.Y[1]*beta[,,m][2:p]/sd.X                                         # core
} else {
for (mc in 1:m) {
beta.tilde[,,m][1:p] <- sd.Y[1]*beta[,,m][1:p]/sd.X                                       # no intercept, core
}
}
}
return(list(BETA=beta.tilde,
beta=beta,
Z=Z, W=W,
R=R,
it=it.stop))
}
kappa1 <- function(x) {
k1 <- rep(1/2,length(x))
tt <- which(abs(x)<=0.0001)
k1[tt] <- 1/2 + x[tt]/12 - x[tt]^3/720 + x[tt]^5/30240
tt <- which(abs(x)>0.0001)
k1[tt] <- 1 - 1/(x[tt]) - 1/(1-exp(x[tt]))
return(k1)
}
# Load necessary library
library(ggplot2)
# Parameters
n <- 405  # Number of samples
p <- 404     # Number of predictors
# Generate random predictors
set.seed(123)
X <- matrix(runif(n * p, -1, 1), nrow=n, ncol=p)
dim(X)
# Choose betas
betas <- c(c(1, 2, -3), c(array(0,401))  )
# Calculate linear predictor
linear_predictor <- X %*% betas
dim(linear_predictor)
# Apply logistic function to get probabilities
mu <- 1 / (1 + exp(-linear_predictor))
# Sample y from the continuous Bernoulli distribution
sample_continuous_bernoulli <- function(mu) {
if (mu == 0.5) {
return(0.5)
} else {
return(log(2 * mu - 1) / log(mu))
}
}
y <- sapply(mu, sample_continuous_bernoulli)
# Plot histogram of y
qplot(y, geom="histogram", bins=30, main="Histogram of y", xlab="y", fill=I("blue"), col=I("black"))
libs_path<-file.path("..","libs")
source(file.path(libs_path,'Shim3way_class.R'))
source(file.path(libs_path,'hierarchy_tests.R'))
source(file.path(libs_path,'recover_parameters.R'))
data<- create_basic_dataset_bern()
X<- data$X
y<- data$y$obs
y<-array(y, dim=(c(length(y),1)) )
class(y)
class(linear_predictor)
class(X)
dim(y)
res_lasso<-irlasso.cb(X=X, Y=y, lambda=0.0001, w.lambda=NULL, beta0=NULL,
centering=FALSE, scaling=FALSE, intercept=F,
maxit=10, tol=0.0545, sd.tol=1e-6,
verbose=TRUE)
y_pred<-kappa1(X%*%array(res_lasso$BETA, dim=c(length(res_lasso$BETA),1) )[-1]  + res_lasso$BETA[1] )
y_pred<-kappa1(X%*%array(res_lasso$BETA, dim=c(length(res_lasso$BETA),1) )  + res_lasso$BETA[1]*0 )
print(r2(y,y_pred))
libs_path<-file.path("..","libs")
source(file.path(libs_path,'Shim3way_class.R'))
source(file.path(libs_path,'hierarchy_tests.R'))
source(file.path(libs_path,'recover_parameters.R'))
data<- create_basic_dataset_bern()
X<- data$X
y<- data$y$obs
y<-array(y, dim=(c(length(y),1)) )
class(y)
class(linear_predictor)
libs_path<-file.path("..","libs")
source(file.path(libs_path,'Shim3way_class.R'))
source(file.path(libs_path,'hierarchy_tests.R'))
source(file.path(libs_path,'recover_parameters.R'))
data<- create_basic_dataset_bern()
X<- data$X
y<- data$y$obs
y<-array(y, dim=(c(length(y),1)) )
res_lasso<-irlasso.cb(X=X, Y=y, lambda=0.0001, w.lambda=NULL, beta0=NULL,
centering=FALSE, scaling=FALSE, intercept=F,
maxit=10, tol=0.0545, sd.tol=1e-6,
verbose=TRUE)
libs_path<-file.path("..","libs")
source(file.path(libs_path,'Shim3way_GLM.R'))
source(file.path(libs_path,'hierarchy_tests.R'))
source(file.path(libs_path,'recover_parameters.R'))
data<- create_basic_dataset_bern()
X<- data$X
y<- data$y$obs
y<-array(y, dim=(c(length(y),1)) )
res_lasso<-irlasso.cb(X=X, Y=y, lambda=0.0001, w.lambda=NULL, beta0=NULL,
centering=FALSE, scaling=FALSE, intercept=F,
maxit=10, tol=0.0545, sd.tol=1e-6,
verbose=TRUE)
y_pred<-kappa1(X%*%array(res_lasso$BETA, dim=c(length(res_lasso$BETA),1) )  + res_lasso$BETA[1]*0 )
beta_true<- data$beta[-1,]
l1=8
l2=8
l3=4
#print(beta_true)
range_main<-c(1: (l1+l2+l3) )
range_theta<-c( (l1+l2+l3+1) : (l1+l2+l3+l1*(l2+l3)+l2*l3) )
range_psi<-c(  (l1+l2+l3+ 1+ l1*(l2+l3)+l2*l3): (l1+l2+l3+ l1*(l2+l3)+l2*l3+l1*l2*l3) )
beta_main<-beta_true[1:(l1+l2+l3)]
beta_2way<-beta_true[unlist(get_ranges(l1,l2,l3)[2])]
beta_3way<-beta_true[unlist(get_ranges(l1,l2,l3)[3])]
beta_2way_matrix<-get_theta_from_theta_vec_2way3(beta_2way,l1=l1,l2=l2, l3=l3)
beta_3way_table<-get_psi_from_psi_vec3(beta_3way,l1=l1,l2=l2, l3=l3)
beta_main_recovered<- get_all_beta(beta_main, l1=l1, l2=l2, l3=l3, threshold = 1e-4)
beta_2way_recovered<-  get_theta_vec_2way3(  get_all_theta(beta_2way_matrix, l1=l1, l2=l2, l3=l3, threshold = 1e-4), l1=l1+1, l2=l2+1, l3=l3+1)
beta_3way_recovered<- get_psi_vec3( get_all_psi(beta_3way_table, l1=l1, l2=l2, l3=l3, threshold = 1e-4) , l1=l1+1, l2=l2+1, l3=l3+1)
beta_2way_without_gamma<-get_beta_vec_2way(beta = beta_main, l1=l1, l2=l2, l3=l3, gamma=NULL, only_beta = TRUE )
beta_3way_without_gamma<-get_beta_vec_3way(beta_2way = beta_2way, l1=l1, l2=l2, l3=l3, delta = NULL, only_beta = TRUE)
gamma_true<-beta_2way/beta_2way_without_gamma
gamma_true[is.nan(gamma_true)]<-0
delta_true<-beta_3way/beta_3way_without_gamma
delta_true[is.nan(delta_true)]<-0
####START LASSO
lambda=0.0001
res_lasso<-irlasso.cb(X=X, Y=y, lambda=lambda, w.lambda=NULL, beta0=NULL,
centering=FALSE, scaling=FALSE, intercept=F,
maxit=10, tol=0.0545, sd.tol=1e-6,
verbose=TRUE)
coefs_lasso<-res_lasso$BETA
beta_main_lasso<-coefs_lasso[range_main]
beta_2way_lasso<-coefs_lasso[range_theta]
beta_3way_lasso<-coefs_lasso[range_psi]
beta_2way_lasso_without_gamma<-get_beta_vec_2way(beta_main_lasso,l1=l1,l2=l2,l3=l3,only_beta = TRUE)
beta_3way_lasso_without_delta<- get_beta_vec_3way(beta_2way_lasso, l1=l1, l2=l2, l3=l3, only_beta = TRUE)
predict_lasso<-kappa1(X%*%array(coefs_lasso, dim=c(length(coefs_lasso),1) )  ) #no intercept
print(r2(y, predict_lasso))
#length(c(beta_main, beta_2way, beta_3way))
######################### RESULTS LASSO #########################################################
print(" results lasso without recovered")
all_beta_functions(beta_main, beta_main_lasso)
all_beta_functions(beta_2way, beta_2way_lasso)
all_beta_functions(beta_3way, beta_3way_lasso)
##### RESULTS LASSO ON RECOVERED PARAMS ##########
beta_2way_lasso_matrix<-get_theta_from_theta_vec_2way3(beta_2way_lasso,l1=l1,l2=l2, l3=l3)
beta_3way_lasso_table<-get_psi_from_psi_vec3(beta_3way_lasso,l1=l1,l2=l2, l3=l3)
##hierarchy tests
test_hierarchy_layer12(beta_main_lasso,beta_2way_lasso_matrix, strong = TRUE)
test_hierarchy_layer23(beta_2way_lasso_matrix, beta_3way_lasso_table, strong = TRUE)
beta_main_lasso_recovered<- get_all_beta(beta_main_lasso, l1=l1, l2=l2, l3=l3, threshold = 1e-4)
beta_2way_lasso_recovered<-  get_theta_vec_2way3(  get_all_theta(beta_2way_lasso_matrix, l1=l1, l2=l2, l3=l3, threshold = 1e-4), l1=l1+1, l2=l2+1, l3=l3+1)
beta_3way_lasso_recovered<- get_psi_vec3( get_all_psi(beta_3way_lasso_table, l1=l1, l2=l2, l3=l3, threshold = 1e-4) , l1=l1+1, l2=l2+1, l3=l3+1)
print("results lasso recovered")
all_beta_functions(beta_main_recovered, beta_main_lasso_recovered)
all_beta_functions(beta_2way_recovered, beta_2way_lasso_recovered)
all_beta_functions(beta_3way_recovered, beta_3way_lasso_recovered)
##PREPARE FOR SHIM ###################################################################################################
beta_hat<-beta_main_lasso
gamma_hat<- beta_2way_lasso/beta_2way_lasso_without_gamma
gamma_hat[is.nan(gamma_hat)]<-0
gamma_hat[!is.finite(gamma_hat)]<-0 #this is 0 in shim case
delta_hat<- beta_3way_lasso/beta_3way_lasso_without_delta
delta_hat[!is.finite(delta_hat)]<-0
delta_hat[is.nan(delta_hat)]<-0
lambda=0.001
res_lasso<-irlasso.cb(X=X, Y=y, lambda=lambda, w.lambda=NULL, beta0=NULL,
centering=FALSE, scaling=FALSE, intercept=F,
maxit=10, tol=0.0545, sd.tol=1e-6,
verbose=TRUE)
coefs_lasso<-res_lasso$BETA
beta_main_lasso<-coefs_lasso[range_main]
beta_2way_lasso<-coefs_lasso[range_theta]
beta_3way_lasso<-coefs_lasso[range_psi]
beta_2way_lasso_without_gamma<-get_beta_vec_2way(beta_main_lasso,l1=l1,l2=l2,l3=l3,only_beta = TRUE)
beta_3way_lasso_without_delta<- get_beta_vec_3way(beta_2way_lasso, l1=l1, l2=l2, l3=l3, only_beta = TRUE)
predict_lasso<-kappa1(X%*%array(coefs_lasso, dim=c(length(coefs_lasso),1) )  ) #no intercept
print(r2(y, predict_lasso))
#length(c(beta_main, beta_2way, beta_3way))
######################### RESULTS LASSO #########################################################
print(" results lasso without recovered")
all_beta_functions(beta_main, beta_main_lasso)
all_beta_functions(beta_2way, beta_2way_lasso)
all_beta_functions(beta_3way, beta_3way_lasso)
##### RESULTS LASSO ON RECOVERED PARAMS ##########
beta_2way_lasso_matrix<-get_theta_from_theta_vec_2way3(beta_2way_lasso,l1=l1,l2=l2, l3=l3)
beta_3way_lasso_table<-get_psi_from_psi_vec3(beta_3way_lasso,l1=l1,l2=l2, l3=l3)
##hierarchy tests
test_hierarchy_layer12(beta_main_lasso,beta_2way_lasso_matrix, strong = TRUE)
test_hierarchy_layer23(beta_2way_lasso_matrix, beta_3way_lasso_table, strong = TRUE)
beta_main_lasso_recovered<- get_all_beta(beta_main_lasso, l1=l1, l2=l2, l3=l3, threshold = 1e-4)
beta_2way_lasso_recovered<-  get_theta_vec_2way3(  get_all_theta(beta_2way_lasso_matrix, l1=l1, l2=l2, l3=l3, threshold = 1e-4), l1=l1+1, l2=l2+1, l3=l3+1)
beta_3way_lasso_recovered<- get_psi_vec3( get_all_psi(beta_3way_lasso_table, l1=l1, l2=l2, l3=l3, threshold = 1e-4) , l1=l1+1, l2=l2+1, l3=l3+1)
print("results lasso recovered")
all_beta_functions(beta_main_recovered, beta_main_lasso_recovered)
all_beta_functions(beta_2way_recovered, beta_2way_lasso_recovered)
all_beta_functions(beta_3way_recovered, beta_3way_lasso_recovered)
##PREPARE FOR SHIM ###################################################################################################
beta_hat<-beta_main_lasso
gamma_hat<- beta_2way_lasso/beta_2way_lasso_without_gamma
gamma_hat[is.nan(gamma_hat)]<-0
gamma_hat[!is.finite(gamma_hat)]<-0 #this is 0 in shim case
delta_hat<- beta_3way_lasso/beta_3way_lasso_without_delta
delta_hat[!is.finite(delta_hat)]<-0
delta_hat[is.nan(delta_hat)]<-0
beta_main_recovered
beta_main_lasso_recovered
beta_hat<-beta_main_lasso
gamma_hat<- beta_2way_lasso/beta_2way_lasso_without_gamma
gamma_hat[is.nan(gamma_hat)]<-0
gamma_hat[!is.finite(gamma_hat)]<-0 #this is 0 in shim case
delta_hat<- beta_3way_lasso/beta_3way_lasso_without_delta
delta_hat[!is.finite(delta_hat)]<-0
delta_hat[is.nan(delta_hat)]<-0
beta_hat<-beta_main_lasso
gamma_hat<- beta_2way_lasso/beta_2way_lasso_without_gamma
gamma_hat[is.nan(gamma_hat)]<-0
gamma_hat[!is.finite(gamma_hat)]<-0 #this is 0 in shim case
delta_hat<- beta_3way_lasso/beta_3way_lasso_without_delta
delta_hat[!is.finite(delta_hat)]<-0
delta_hat[is.nan(delta_hat)]<-0
lambda_beta<-0.3
lambda_gamma<-2.2
lambda_delta<-0.7
my_shim<-SHIM_3way(X=X, y=y, beta_init = beta_hat, gamma_init = gamma_hat, delta_init = delta_hat, l1=l1, l2=l2, l3=l3, scale = FALSE)
fitted<-my_shim$fit(X=X, y=y, lambda_beta = lambda_beta,
lambda_gamma = lambda_gamma, lambda_delta = lambda_delta, w_beta = 1, w_gamma = 1, w_delta = 1, tol=1e-2)
source(file.path(libs_path,'Shim3way_GLM.R'))
my_shim<-SHIM_3way(X=X, y=y, beta_init = beta_hat, gamma_init = gamma_hat, delta_init = delta_hat, l1=l1, l2=l2, l3=l3, scale = FALSE)
fitted<-my_shim$fit(X=X, y=y, lambda_beta = lambda_beta,
lambda_gamma = lambda_gamma, lambda_delta = lambda_delta, w_beta = 1, w_gamma = 1, w_delta = 1, tol=1e-2)
libs_path<-file.path("..","libs")
source(file.path(libs_path,'Shim3way_GLM.R'))
source(file.path(libs_path,'hierarchy_tests.R'))
source(file.path(libs_path,'recover_parameters.R'))
libs_path<-file.path("..","libs")
source(file.path(libs_path,'Shim3way_GLM.R'))
source(file.path(libs_path,'hierarchy_tests.R'))
source(file.path(libs_path,'recover_parameters.R'))
my_shim<-SHIM_3way(X=X, y=y, beta_init = beta_hat, gamma_init = gamma_hat, delta_init = delta_hat, l1=l1, l2=l2, l3=l3, scale = FALSE)
fitted<-my_shim$fit(X=X, y=y, lambda_beta = lambda_beta,
lambda_gamma = lambda_gamma, lambda_delta = lambda_delta, w_beta = 1, w_gamma = 1, w_delta = 1, tol=1e-2)
delta_hat[1]=178
delta_hat[1]=178
my_shim<-SHIM_3way(X=X, y=y, beta_init = beta_hat, gamma_init = gamma_hat, delta_init = delta_hat, l1=l1, l2=l2, l3=l3, scale = FALSE)
fitted<-my_shim$fit(X=X, y=y, lambda_beta = lambda_beta,
lambda_gamma = lambda_gamma, lambda_delta = lambda_delta, w_beta = 1, w_gamma = 1, w_delta = 1, tol=1e-2)
beta_hat<-beta_main_lasso
gamma_hat<- beta_2way_lasso/beta_2way_lasso_without_gamma
gamma_hat[is.nan(gamma_hat)]<-0
gamma_hat[!is.finite(gamma_hat)]<-0 #this is 0 in shim case
delta_hat<- beta_3way_lasso/beta_3way_lasso_without_delta
delta_hat[!is.finite(delta_hat)]<-0
delta_hat[is.nan(delta_hat)]<-0
beta_hat<-beta_main_lasso
gamma_hat<- beta_2way_lasso/beta_2way_lasso_without_gamma
gamma_hat[is.nan(gamma_hat)]<-0
gamma_hat[!is.finite(gamma_hat)]<-0 #this is 0 in shim case
delta_hat<- beta_3way_lasso/beta_3way_lasso_without_delta
delta_hat[!is.finite(delta_hat)]<-0
delta_hat[is.nan(delta_hat)]<-0
beta_hat<-beta_main_lasso
gamma_hat<- beta_2way_lasso/beta_2way_lasso_without_gamma
gamma_hat[is.nan(gamma_hat)]<-0
gamma_hat[!is.finite(gamma_hat)]<-0 #this is 0 in shim case
delta_hat<- beta_3way_lasso/beta_3way_lasso_without_delta
delta_hat[!is.finite(delta_hat)]<-0
delta_hat[is.nan(delta_hat)]<-0
delta_hat
delta_true
delta_hat[1]=17888888
my_shim<-SHIM_3way(X=X, y=y, beta_init = beta_hat, gamma_init = gamma_hat, delta_init = delta_hat, l1=l1, l2=l2, l3=l3, scale = FALSE)
fitted<-my_shim$fit(X=X, y=y, lambda_beta = lambda_beta,
lambda_gamma = lambda_gamma, lambda_delta = lambda_delta, w_beta = 1, w_gamma = 1, w_delta = 1, tol=1e-2)
gamma_hat
delta_hat
delta_hat
delta_hat[2]=17888888
my_shim<-SHIM_3way(X=X, y=y, beta_init = beta_hat, gamma_init = gamma_hat, delta_init = delta_hat, l1=l1, l2=l2, l3=l3, scale = FALSE)
fitted<-my_shim$fit(X=X, y=y, lambda_beta = lambda_beta,
lambda_gamma = lambda_gamma, lambda_delta = lambda_delta, w_beta = 1, w_gamma = 1, w_delta = 1, tol=1e-2)
beta_hat<-beta_main_lasso
gamma_hat<- beta_2way_lasso/beta_2way_lasso_without_gamma
gamma_hat[is.nan(gamma_hat)]<-0
gamma_hat[!is.finite(gamma_hat)]<-0 #this is 0 in shim case
delta_hat<- beta_3way_lasso/beta_3way_lasso_without_delta
delta_hat[!is.finite(delta_hat)]<-0
delta_hat[is.nan(delta_hat)]<-0
beta_hat<-beta_main_lasso
gamma_hat<- beta_2way_lasso/beta_2way_lasso_without_gamma
gamma_hat[is.nan(gamma_hat)]<-0
gamma_hat[!is.finite(gamma_hat)]<-0 #this is 0 in shim case
delta_hat<- beta_3way_lasso/beta_3way_lasso_without_delta
delta_hat[!is.finite(delta_hat)]<-0
delta_hat[is.nan(delta_hat)]<-0
delta_hat
gamma_hat
delta_hat=17888888+delta_hat
my_shim<-SHIM_3way(X=X, y=y, beta_init = beta_hat, gamma_init = gamma_hat, delta_init = delta_hat, l1=l1, l2=l2, l3=l3, scale = FALSE)
fitted<-my_shim$fit(X=X, y=y, lambda_beta = lambda_beta,
lambda_gamma = lambda_gamma, lambda_delta = lambda_delta, w_beta = 1, w_gamma = 1, w_delta = 1, tol=1e-2)
##USE SHIM MODEL #########
lambda_beta<-0
lambda_gamma<-1e-5
lambda_delta<-1e-4
#delta_hat=delta_hat+rnorm(length(delta_hat))
#delta_true
source(file.path(libs_path,'Shim3way_GLM.R'))
